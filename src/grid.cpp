#include <rrt/grid.h>

#include <algorithm>
#include <cmath>
#include <functional>
#include <stdexcept>

namespace grid {

Grid::Grid(const Map &map) : map_(map) {
  if (map_.height * map_.width != map_.occupancy.size())
    throw std::runtime_error("Map size does not agree with map height and width!");
}

///////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////

bool Grid::isValidPosition(const types::WorldPosition &position) const {
  return isWithinGrid_(position) && isFreeMapCell_(fromWorldToGrid_(position));
}

///////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////

types::GridPosition Grid::fromWorldToGrid_(const types::WorldPosition &world_position) const {
  return types::GridPosition({.x = static_cast<size_t>(std::floor((world_position.x - map_.origin.x) / map_.resolution)),
                              .y = static_cast<size_t>(std::floor((world_position.y - map_.origin.y) / map_.resolution))});
}

///////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////

size_t Grid::fromGridToMap_(const types::GridPosition &grid_position) const {
  return grid_position.x + grid_position.y * map_.width;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////

bool Grid::isWithinGrid_(const types::WorldPosition &position) const {
  return position.x >= map_.origin.x &&
         position.x <= map_.origin.x + static_cast<double>(map_.width) * map_.resolution &&
         position.y >= map_.origin.y &&
         position.y <= map_.origin.y + static_cast<double>(map_.height) * map_.resolution;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////

bool Grid::straightLineFeasible_(const types::WorldPosition &world_p1, const types::WorldPosition &world_p2) const {
  if (!isWithinGrid_(world_p1) || ! isWithinGrid_(world_p2))
    return false;

  auto p1 = fromWorldToGrid_(world_p1);
  auto p2 = fromWorldToGrid_(world_p2);

  long int dx = p1.x > p2.x ? static_cast<long int>(p1.x - p2.x) : static_cast<long int>(p2.x - p1.x);
  long int dy = p1.y > p2.y ? static_cast<long int>(p1.y - p2.y) : static_cast<long int>(p2.y - p1.y);
  long int n = 1 + dx + dy;

  long int error = dx - dy;
  dx *= 2;
  dy *= 2;

  types::GridPosition p{.x = p1.x, .y = p1.y};
  std::function<void()> step_x, step_y;
  if (p2.x > p1.x)
    step_x = [&p] () {++p.x;};
  else
    step_x = [&p] () {--p.x;};

  if (p2.y > p1.y)
    step_y = [&p] () {++p.y;};
  else
    step_y = [&p] () {--p.y;};

  for (long int i = 0; i < n; ++i) {
    if (!isFreeMapCell_(p))
      return false;
    
    if (error > 0) {
      step_x();
      error -= dy;
    } else {
      step_y();
      error += dx;
    }
  }
  return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////

bool Grid::isFreeMapCell_(const types::GridPosition &p) const {
  return map_.occupancy.at(fromGridToMap_(p)) == Map::Cell::FREE;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////

bool Grid::collisionFree(const types::Path &path) const {
  if (path.size() <= 1)
    throw std::invalid_argument("Can't check collision, path size is invalid!");
  
  for (size_t i = 0; i < path.size() - 1; ++i)
    if (!straightLineFeasible_(path[i].position, path[i + 1].position))
      return false;

  return true;
}

} // namespace grid